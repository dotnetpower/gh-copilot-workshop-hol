---
sidebar_position: 9
title: 프롬프트 엔지니어링 이해
description: AI 모델로부터 원하는 결과를 얻기 위한 효과적인 프롬프트 작성 기술
---

# 프롬프트 엔지니어링 이해

## 프롬프트 엔지니어링이란?

프롬프트 엔지니어링은 대규모 언어 모델(LLM)로부터 원하는 결과를 얻기 위해 효과적인 입력(프롬프트)을 설계하고 최적화하는 기술입니다. 이는 AI 모델의 성능을 최대화하고 더 나은 결과를 얻기 위한 핵심 스킬입니다.

## 왜 중요한가?

### 1. 정확성 향상
- 명확한 프롬프트 → 정확한 코드
- 모호한 요청 → 예상치 못한 결과
- 올바른 프롬프트 기법으로 작업 성공률 대폭 향상

### 2. 생산성 증대
- 첫 시도에서 원하는 결과 획득
- 반복 수정 시간 감소
- 복잡한 작업을 효과적으로 처리

### 3. 코드 품질 개선
- 베스트 프랙티스 적용 요청 가능
- 특정 패턴이나 스타일 지정 가능
- 더 신뢰할 수 있는 결과 생성

## 기본 원칙

### 명확성 (Clarity)
```javascript title="명확한 주석 예시"
// ❌ 나쁨 예: 모호한 주석
// 함수 만들기

// ✅ 좋은 예: 명확한 주석
// 두 숫자를 입력받아 합계를 반환하는 함수를 작성
function add(a, b) {
    return a + b;
}
```

### 구체성 (Specificity)
```python title="구체적인 요청 예시"
# ❌ 나쁨 예: 일반적인 요청
# 데이터 처리

# ✅ 좋은 예: 구체적인 요청
# CSV 파일에서 데이터를 읽어 판다스 DataFrame으로 변환하고,
# 'age' 컬럼의 평균값을 계산하는 함수
```

### 컨텍스트 제공
```python
# 기존 코드와 함께 사용될 컨텍스트 제공
from typing import TypedDict

class User(TypedDict):
    id: int
    name: str
    email: str

# User 리스트에서 특정 이메일을 가진 사용자를 찾는 함수
def find_user_by_email(users: list[User], email: str) -> User | None:
    return next((user for user in users if user['email'] == email), None)
```

## 주요 프롬프트 기법

### 1. Zero-shot Prompting (제로샷 프롬프팅)

Zero-shot 프롬프팅은 모델에게 예시를 제공하지 않고 직접 작업을 지시하는 방법입니다. GPT-4, Claude 3 같은 대규모 모델들은 별도의 예시 없이도 많은 작업을 수행할 수 있습니다.

**예시:**
```text
다음 텍스트를 중립, 부정, 긍정으로 분류하세요.

텍스트: 휴가는 괜찮았어요.
감정:
```

**출력:**
```text
중립
```

**장점:**
- 간단하고 빠른 적용
- 예시 준비 불필요
- 다양한 작업에 즉시 활용 가능

**한계:**
- 복잡한 추론 작업에는 부족할 수 있음
- 특정 포맷이나 스타일 요구 시 불안정

### 2. Few-shot Prompting (퓨샷 프롬프팅)

Few-shot 프롬프팅은 모델에게 몇 가지 예시를 제공하여 원하는 작업을 학습시키는 방법입니다. 이는 in-context learning을 활용하여 모델의 성능을 향상시킵니다.

**예시:**
```text
"whatpu"는 탄자니아에 서식하는 작고 털이 많은 동물입니다. 
whatpu를 사용한 문장의 예: 우리는 아프리카를 여행하다가 매우 귀여운 whatpu들을 보았습니다.

"farduddle"은 매우 빠르게 위아래로 점프하는 것을 의미합니다. 
farduddle을 사용한 문장의 예:
```

**출력:**
```text
우리가 게임에서 이겼을 때, 우리 모두 기뻐서 farduddle하기 시작했습니다.
```

**효과적인 Few-shot 팁:**
- 라벨 공간과 입력 텍스트 분포가 중요 (개별 라벨의 정확성보다)
- 포맷이 매우 중요함
- 랜덤 라벨이라도 라벨이 없는 것보다 나음
- 실제 라벨 분포에서 샘플링하는 것이 더 효과적

**한계:**
- 복잡한 추론 작업에는 여전히 부족할 수 있음
- 예시 작성에 시간 소요
- 긴 프롬프트로 인한 토큰 비용 증가

### 3. Chain-of-Thought Prompting (사고 과정 프롬프팅)

Chain-of-Thought (CoT) 프롬프팅은 모델이 중간 추론 단계를 거쳐 복잡한 문제를 해결하도록 유도하는 기법입니다. 이는 산술, 상식 추론, 기호 추론 등의 복잡한 작업에 특히 효과적입니다.

**표준 프롬프팅 vs CoT 프롬프팅 비교:**

```text
Q: 이 그룹의 홀수를 모두 더하면 짝수가 됩니다: 4, 8, 9, 15, 12, 2, 1.
A: 25. 답은 거짓입니다.

Q: 이 그룹의 홀수를 모두 더하면 짝수가 됩니다: 17, 10, 19, 4, 8, 12, 24.
A: 36. 답은 참입니다.

Q: 이 그룹의 홀수를 모두 더하면 짝수가 됩니다: 16, 11, 14, 4, 8, 13, 24.
A: 24. 답은 참입니다.

Q: 이 그룹의 홀수를 모두 더하면 짝수가 됩니다: 17, 9, 10, 12, 13, 4, 2.
A: 39. 답은 거짓입니다.

Q: 이 그룹의 홀수를 모두 더하면 짝수가 됩니다: 15, 32, 5, 13, 82, 7, 1.
A:
```

**출력:**
```text
모든 홀수(15, 5, 13, 7, 1)를 더하면 41입니다. 답은 거짓입니다.
```

**장점:**
- 복잡한 추론 작업에서 획기적인 성능 향상
- 모델의 사고 과정을 추적 가능
- 신뢰성과 해석 가능성 향상

### 4. Zero-shot CoT

Zero-shot CoT는 단순히 "**단계별로 생각해봅시다 (Let's think step by step)**"라는 문구를 추가하는 것만으로 모델이 추론 체인을 생성하도록 유도합니다.

**예시:**
```text
시장에 가서 사과 10개를 샀습니다. 
이웃에게 2개, 수리공에게 2개를 주었습니다.
그 후 5개를 더 사서 1개를 먹었습니다.
몇 개가 남았습니까?

단계별로 생각해봅시다.
```

**출력:**
```text
먼저, 10개의 사과로 시작했습니다.
이웃에게 2개, 수리공에게 2개를 주어서 6개가 남았습니다.
그 후 5개를 더 사서 11개가 되었습니다.
마지막으로 1개를 먹어서 10개가 남았습니다.
```

**적용 시점:**
- 예시를 만들 시간이 없을 때
- 복잡한 추론이 필요한 작업
- 빠른 프로토타이핑

### 5. Self-Consistency (자기 일관성)

여러 추론 경로를 생성하고 가장 일관성 있는 답을 선택하는 방법입니다. CoT와 결합하면 더욱 강력합니다.

### 6. Generated Knowledge Prompting (지식 생성 프롬프팅)

답변하기 전에 관련 지식을 먼저 생성하도록 요청하는 방법입니다.

**예시:**
```text
주제에 대한 배경 지식을 먼저 생성하고, 그 지식을 활용하여 질문에 답변하세요.

주제: 기후 변화
질문: 기후 변화가 해양 생태계에 미치는 영향은?
```

## GitHub Copilot에서의 실전 활용

### 코드 생성 시 효과적인 프롬프팅

```python
# ❌ 비효과적인 프롬프트
# 데이터베이스 함수

# ✅ 효과적인 프롬프트 (CoT 적용)
# 사용자 인증을 처리하는 함수를 작성합니다.
# 1. 이메일과 비밀번호를 입력받습니다
# 2. 비밀번호를 해싱합니다 (bcrypt 사용)
# 3. 데이터베이스에서 사용자를 조회합니다
# 4. 비밀번호가 일치하면 JWT 토큰을 반환합니다
# 5. 실패 시 적절한 에러를 발생시킵니다
```

### Copilot Chat에서 Few-shot 활용

```text
다음과 같은 스타일로 테스트 코드를 작성해주세요:

[예시 1]
def test_user_creation():
    user = create_user("test@example.com", "password123")
    assert user.email == "test@example.com"
    assert user.is_active == True

[예시 2]
def test_user_update():
    user = create_user("test@example.com", "password123")
    update_user(user.id, name="John Doe")
    assert user.name == "John Doe"

이제 delete_user 함수에 대한 테스트를 작성해주세요.
```

### 복잡한 리팩토링에 CoT 적용

```text
다음 코드를 SOLID 원칙에 맞게 리팩토링해주세요.

단계별 접근:
1. 단일 책임 원칙 위반 사항 파악
2. 각 책임을 별도 클래스로 분리
3. 의존성 주입 패턴 적용
4. 인터페이스 추출
5. 최종 리팩토링된 코드 제공

[현재 코드]
```

## 프롬프팅 모범 사례

### 1. 명령어를 명확하게 작성
```text
❌ "코드 좀 작성해줘"
✅ "Python으로 CSV 파일을 읽어 판다스 DataFrame으로 변환하고, 'age' 컬럼의 결측치를 중앙값으로 채우는 함수를 작성해주세요"
```

### 2. 구분자 사용
```text
다음 텍스트를 요약해주세요:
###
[긴 텍스트 내용]
###
```

### 3. 출력 형식 지정
```text
다음 형식의 JSON으로 응답해주세요:
{
  "name": "함수명",
  "parameters": ["param1", "param2"],
  "return_type": "반환 타입"
}
```

### 4. 조건부 실행 명시
```text
입력이 유효하면 처리하고, 유효하지 않으면 "유효하지 않은 입력"을 반환하는 함수를 작성하세요.
```

### 5. 예시 제공 (Few-shot)
```text
다음 패턴을 따라 작성하세요:

입력: "안녕하세요"
출력: "GREETING"

입력: "도움이 필요해요"
출력: "HELP_REQUEST"

입력: "감사합니다"
출력:
```

## 고급 기법

### Prompt Chaining (프롬프트 체이닝)
복잡한 작업을 여러 단계로 나누어 순차적으로 처리:

```text
1단계: 요구사항 분석
2단계: 데이터 모델 설계
3단계: API 엔드포인트 설계
4단계: 구현 코드 생성
5단계: 테스트 코드 생성
```

### Tree of Thoughts (사고의 나무)
여러 추론 경로를 탐색하고 평가:

```text
문제: [복잡한 알고리즘 설계]

접근 방법 1: 재귀적 해결
- 장점: ...
- 단점: ...

접근 방법 2: 반복적 해결
- 장점: ...
- 단점: ...

접근 방법 3: 동적 프로그래밍
- 장점: ...
- 단점: ...

최적 접근 방법 선택 및 구현
```

### Meta Prompting
프롬프트를 생성하는 프롬프트:

```text
다음 작업을 수행하기 위한 최적의 프롬프트를 생성해주세요:
작업: [구체적인 작업 설명]
제약 조건: [제약사항]
원하는 출력 형식: [형식 설명]
```

## 실습 과제

### 과제 1: Zero-shot → Few-shot → CoT 비교
다음 작업을 세 가지 방식으로 요청하고 결과를 비교해보세요:
- 작업: "문자열 배열을 받아 중복을 제거하고 알파벳순으로 정렬하는 함수"

### 과제 2: 복잡한 작업에 CoT 적용
다음 요구사항을 CoT 방식으로 작성해보세요:
- "사용자 인증, 권한 관리, 로깅이 포함된 REST API 엔드포인트"

### 과제 3: Few-shot으로 코드 스타일 학습
기존 코드 스타일을 Few-shot 예시로 제공하고 일관된 스타일의 새 함수 생성

## 참고 자료

- [Prompt Engineering Guide](https://www.promptingguide.ai/)
- [OpenAI Prompt Engineering Guide](https://platform.openai.com/docs/guides/prompt-engineering)
- [Anthropic Prompt Engineering Guide](https://docs.anthropic.com/claude/docs/prompt-engineering)

## 요약

효과적인 프롬프트 엔지니어링의 핵심:

1. **명확하고 구체적으로** - 모호함을 제거
2. **적절한 기법 선택** - 작업 복잡도에 따라 Zero-shot, Few-shot, CoT 선택
3. **컨텍스트 제공** - 충분한 배경 정보 제공
4. **구조화된 출력** - 원하는 형식 명시
5. **반복적 개선** - 결과를 보고 프롬프트 조정

프롬프트 엔지니어링은 실습을 통해 향상되는 스킬입니다. 다양한 기법을 실험하고 자신만의 효과적인 패턴을 발견하세요!
